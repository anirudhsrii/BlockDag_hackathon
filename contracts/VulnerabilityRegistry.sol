// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @title VulnerabilityRegistry
 * @dev Contract to store common vulnerability patterns
 */
contract VulnerabilityRegistry {
    address public admin;
    
    // Structure to store vulnerability pattern
    struct VulnerabilityPattern {
        uint256 id;
        string name;
        string pattern;
        string description;
        uint256 severityLevel; // 1-5, where 5 is highest severity
        bool isActive;
    }
    
    // Array to store all vulnerability patterns
    VulnerabilityPattern[] public vulnerabilityPatterns;
    
    // Events
    event PatternAdded(uint256 indexed id, string name, uint256 severityLevel);
    event PatternUpdated(uint256 indexed id, string name, uint256 severityLevel);
    event PatternDeactivated(uint256 indexed id);
    event PatternReactivated(uint256 indexed id);
    
    // Modifiers
    modifier onlyAdmin() {
        require(msg.sender == admin, "Not authorized");
        _;
    }
    
    constructor() {
        admin = msg.sender;
        
        // Add some common vulnerability patterns
        addVulnerabilityPattern(
            "Reentrancy",
            "call.value()",
            "Reentrancy vulnerabilities occur when a contract calls an external contract before resolving its state changes.",
            5
        );
        
        addVulnerabilityPattern(
            "Integer Overflow/Underflow",
            "uint/int operations without SafeMath",
            "Arithmetic operations without proper checks can lead to unexpected behavior due to overflow or underflow.",
            4
        );
        
        addVulnerabilityPattern(
            "Unchecked Return Values",
            "call(), send(), transfer()",
            "Failing to check return values from external calls can lead to unexpected behavior.",
            3
        );
        
        addVulnerabilityPattern(
            "Timestamp Dependence",
            "block.timestamp, now",
            "Using block timestamps for critical logic can be manipulated by miners.",
            3
        );
        
        addVulnerabilityPattern(
            "Front-running",
            "tx.gasprice, priorityFee",
            "Transactions can be seen in the mempool and front-run by others.",
            4
        );
    }
    
    /**
     * @dev Add a new vulnerability pattern
     * @param name Name of the vulnerability
     * @param pattern Pattern to identify the vulnerability
     * @param description Detailed description of the vulnerability
     * @param severityLevel Severity level (1-5)
     */
    function addVulnerabilityPattern(
        string memory name,
        string memory pattern,
        string memory description,
        uint256 severityLevel
    ) public onlyAdmin {
        require(severityLevel >= 1 && severityLevel <= 5, "Severity must be between 1-5");
        
        uint256 id = vulnerabilityPatterns.length;
        
        VulnerabilityPattern memory newPattern = VulnerabilityPattern({
            id: id,
            name: name,
            pattern: pattern,
            description: description,
            severityLevel: severityLevel,
            isActive: true
        });
        
        vulnerabilityPatterns.push(newPattern);
        
        emit PatternAdded(id, name, severityLevel);
    }
    
    /**
     * @dev Update an existing vulnerability pattern
     * @param id ID of the vulnerability pattern
     * @param name Updated name
     * @param pattern Updated pattern
     * @param description Updated description
     * @param severityLevel Updated severity level
     */
    function updateVulnerabilityPattern(
        uint256 id,
        string memory name,
        string memory pattern,
        string memory description,
        uint256 severityLevel
    ) public onlyAdmin {
        require(id < vulnerabilityPatterns.length, "Pattern does not exist");
        require(severityLevel >= 1 && severityLevel <= 5, "Severity must be between 1-5");
        
        vulnerabilityPatterns[id].name = name;
        vulnerabilityPatterns[id].pattern = pattern;
        vulnerabilityPatterns[id].description = description;
        vulnerabilityPatterns[id].severityLevel = severityLevel;
        
        emit PatternUpdated(id, name, severityLevel);
    }
    
    /**
     * @dev Deactivate a vulnerability pattern
     * @param id ID of the vulnerability pattern
     */
    function deactivatePattern(uint256 id) public onlyAdmin {
        require(id < vulnerabilityPatterns.length, "Pattern does not exist");
        vulnerabilityPatterns[id].isActive = false;
        emit PatternDeactivated(id);
    }
    
    /**
     * @dev Reactivate a vulnerability pattern
     * @param id ID of the vulnerability pattern
     */
    function reactivatePattern(uint256 id) public onlyAdmin {
        require(id < vulnerabilityPatterns.length, "Pattern does not exist");
        vulnerabilityPatterns[id].isActive = true;
        emit PatternReactivated(id);
    }
    
    /**
     * @dev Get all active vulnerability patterns
     * @return Array of active vulnerability patterns
     */
    function getActivePatterns() public view returns (VulnerabilityPattern[] memory) {
        uint256 activeCount = 0;
        
        for (uint256 i = 0; i < vulnerabilityPatterns.length; i++) {
            if (vulnerabilityPatterns[i].isActive) {
                activeCount++;
            }
        }
        
        VulnerabilityPattern[] memory activePatterns = new VulnerabilityPattern[](activeCount);
        uint256 index = 0;
        
        for (uint256 i = 0; i < vulnerabilityPatterns.length; i++) {
            if (vulnerabilityPatterns[i].isActive) {
                activePatterns[index] = vulnerabilityPatterns[i];
                index++;
            }
        }
        
        return activePatterns;
    }
    
    /**
     * @dev Transfer admin rights
     * @param newAdmin Address of the new admin
     */
    function transferAdmin(address newAdmin) public onlyAdmin {
        require(newAdmin != address(0), "New admin cannot be zero address");
        admin = newAdmin;
    }
}
